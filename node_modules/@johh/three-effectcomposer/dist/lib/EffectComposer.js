'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _ShaderPass = require('./ShaderPass');

var _ShaderPass2 = _interopRequireDefault(_ShaderPass);

var _CopyShader = require('./CopyShader');

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _MaskPass = require('./MaskPass');

var _MaskPass2 = _interopRequireDefault(_MaskPass);

var _ClearMaskPass = require('./ClearMaskPass');

var _ClearMaskPass2 = _interopRequireDefault(_ClearMaskPass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectComposer = function () {
	function EffectComposer(renderer, _renderTarget) {
		_classCallCheck(this, EffectComposer);

		var renderTarget = _renderTarget;

		this.renderer = renderer;

		if (renderTarget === undefined) {

			var parameters = {
				minFilter: THREE.LinearFilter,
				magFilter: THREE.LinearFilter,
				format: THREE.RGBAFormat,
				stencilBuffer: false
			};

			var size = renderer.getSize(new THREE.Vector2());
			this._pixelRatio = renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);

			renderTarget.texture.name = 'EffectComposer.rt1';
		} else {

			this._pixelRatio = 1;
			this._width = renderTarget.width;
			this._height = renderTarget.height;
		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.renderToScreen = true;

		this.passes = [];

		this.copyPass = new _ShaderPass2.default(_CopyShader2.default);

		this.clock = new THREE.Clock();
	}

	_createClass(EffectComposer, [{
		key: 'swapBuffers',
		value: function swapBuffers() {

			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;
		}
	}, {
		key: 'addPass',
		value: function addPass(pass) {

			this.passes.push(pass);

			var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());
			pass.setSize(size.width, size.height);
		}
	}, {
		key: 'insertPass',
		value: function insertPass(pass, index) {

			this.passes.splice(index, 0, pass);
		}
	}, {
		key: 'isLastEnabledPass',
		value: function isLastEnabledPass(passIndex) {

			for (var i = passIndex + 1; i < this.passes.length; i += 1) {

				if (this.passes[i].enabled) {

					return false;
				}
			}

			return true;
		}
	}, {
		key: 'render',
		value: function render() {
			var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.clock.getDelta();


			// deltaTime value is in seconds

			var currentRenderTarget = this.renderer.getRenderTarget();

			var maskActive = false;

			var pass = void 0;
			var i = void 0;
			var il = this.passes.length;

			for (i = 0; i < il; i += 1) {

				pass = this.passes[i];

				if (pass.enabled !== false) {

					pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
					pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

					if (pass.needsSwap) {

						if (maskActive) {
							var context = this.renderer.context;


							context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

							this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

							context.stencilFunc(context.EQUAL, 1, 0xffffffff);
						}

						this.swapBuffers();
					}
				}

				if (pass instanceof _MaskPass2.default) {

					maskActive = true;
				} else if (pass instanceof _ClearMaskPass2.default) {

					maskActive = false;
				}
			}

			this.renderer.setRenderTarget(currentRenderTarget);
		}
	}, {
		key: 'reset',
		value: function reset(_renderTarget) {

			var renderTarget = _renderTarget;

			if (renderTarget === undefined) {

				var size = this.renderer.getSize(new THREE.Vector2());
				this._pixelRatio = this.renderer.getPixelRatio();
				this._width = size.width;
				this._height = size.height;

				renderTarget = this.renderTarget1.clone();
				renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
			}

			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();

			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
		}
	}, {
		key: 'setSize',
		value: function setSize(width, height) {

			this._width = width;
			this._height = height;

			var effectiveWidth = this._width * this._pixelRatio;
			var effectiveHeight = this._height * this._pixelRatio;

			this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
			this.renderTarget2.setSize(effectiveWidth, effectiveHeight);

			for (var i = 0; i < this.passes.length; i += 1) {

				this.passes[i].setSize(effectiveWidth, effectiveHeight);
			}
		}
	}, {
		key: 'setPixelRatio',
		value: function setPixelRatio(pixelRatio) {

			this._pixelRatio = pixelRatio;

			this.setSize(this._width, this._height);
		}
	}]);

	return EffectComposer;
}();

exports.default = EffectComposer;